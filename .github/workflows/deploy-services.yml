name: Service Deployment

on:
  push:
    branches:
      - main
    paths:
      - 'services/**'
      - '.github/workflows/deploy-services.yml'
  workflow_dispatch:
    inputs:
      service:
        description: 'Service to deploy (or "all" for all services)'
        required: true
        default: 'all'
      environment:
        description: 'Target environment'
        required: true
        default: 'production'
        type: choice
        options:
          - production

jobs:
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      services: ${{ steps.changes.outputs.services }}
      matrix: ${{ steps.set-matrix.outputs.matrix }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install PyYAML

      - name: Detect changed services
        id: changes
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "Manual trigger detected - skipping git change detection"
            if [ "${{ inputs.service }}" == "all" ]; then
              SERVICES=$(ls -d services/*/ 2>/dev/null | xargs -n 1 basename | jq -R -s -c 'split("\n")[:-1]')
              echo "Deploying all services: $SERVICES"
            else
              SERVICES='["${{ inputs.service }}"]'
              echo "Deploying selected service: ${{ inputs.service }}"
            fi
          else
            echo "Push trigger detected - checking for changed services"
            # Get changed files, handling first commit or shallow clone
            if git rev-parse HEAD^ >/dev/null 2>&1; then
              CHANGED_FILES=$(git diff --name-only HEAD^ HEAD)
            else
              # First commit or shallow clone - check all files
              CHANGED_FILES=$(git diff --name-only --diff-filter=ACMRT HEAD)
            fi
            SERVICES=$(echo "$CHANGED_FILES" | grep '^services/' | cut -d'/' -f2 | sort -u | jq -R -s -c 'split("\n")[:-1] | map(select(length > 0))')
            
            # If no services changed, set empty array
            if [ -z "$SERVICES" ] || [ "$SERVICES" == "[]" ]; then
              SERVICES='[]'
              echo "No service changes detected"
            else
              echo "Changed services detected: $SERVICES"
            fi
          fi
          
          echo "services=$SERVICES" >> $GITHUB_OUTPUT

      - name: Build deployment matrix
        id: set-matrix
        run: |
          python3 << 'EOF'
          import json
          import yaml
          import os
          from pathlib import Path
          
          services = json.loads(os.environ['SERVICES'])
          target_env = os.environ.get('TARGET_ENV', 'staging')
          
          if not services:
              print(json.dumps({"include": []}))
              with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
                  f.write('matrix={"include":[]}\n')
              exit(0)
          
          # Load servers configuration
          workspace = os.environ['GITHUB_WORKSPACE']
          servers_file = os.path.join(workspace, 'servers.yml')
          with open(servers_file) as f:
              servers_config = yaml.safe_load(f)
          
          # Build deployment matrix
          matrix_items = []
          
          for service_name in services:
              deploy_file = Path(f'services/{service_name}/deploy.yml')
              if not deploy_file.exists():
                  print(f"Warning: No deploy.yml for {service_name}, skipping")
                  continue
              
              with open(deploy_file) as f:
                  deploy_config = yaml.safe_load(f)
              
              targets = deploy_config.get('targets', {})
              target_servers = []
              
              # Determine target servers based on deploy.yml
              if 'servers' in targets:
                  target_servers = targets['servers']
              elif 'roles' in targets:
                  for role in targets['roles']:
                      if role in servers_config.get('role_groups', {}):
                          target_servers.extend(servers_config['role_groups'][role])
              elif 'environments' in targets:
                  for env in targets['environments']:
                      if target_env in targets['environments']:
                          if env in servers_config.get('environments', {}):
                              target_servers.extend(servers_config['environments'][env])
              else:
                  # Default: deploy to all servers in target environment
                  if target_env in servers_config.get('environments', {}):
                      target_servers = servers_config['environments'][target_env]
              
              # Filter by target environment
              filtered_servers = []
              for server_name in target_servers:
                  server_info = servers_config['servers'].get(server_name, {})
                  if server_info.get('environment') == target_env:
                      filtered_servers.append(server_name)
              
              # Create matrix entry for each server
              for server_name in set(filtered_servers):
                  server_info = servers_config['servers'][server_name]
                  matrix_items.append({
                      'service': service_name,
                      'server': server_name,
                      'ip': server_info['ip'],
                      'user': server_info['ssh_user'],
                      'environment': target_env
                  })
          
          matrix = {"include": matrix_items}
          print(json.dumps(matrix, indent=2))
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f'matrix={json.dumps(matrix)}\n')
          EOF
        env:
          SERVICES: ${{ steps.changes.outputs.services }}
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}

  deploy-services:
    needs: detect-changes
    if: (github.event_name == 'workflow_dispatch' || needs.detect-changes.outputs.services != '[]') && needs.detect-changes.outputs.matrix != '{"include":[]}'
    runs-on: ubuntu-latest
    strategy:
      matrix: ${{ fromJson(needs.detect-changes.outputs.matrix) }}
      fail-fast: false
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install PyYAML

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ matrix.ip }} >> ~/.ssh/known_hosts

      - name: Load deployment configuration
        id: deploy-config
        run: |
          python3 << 'EOF'
          import yaml
          import os
          
          service = os.environ['SERVICE']
          
          with open(f'services/{service}/deploy.yml') as f:
              config = yaml.safe_load(f)
          
          deploy_type = config['service']['type']
          secrets_required = config.get('secrets', {}).get('required', False)
          
          with open(os.environ['GITHUB_OUTPUT'], 'a') as f:
              f.write(f'type={deploy_type}\n')
              f.write(f'secrets_required={str(secrets_required).lower()}\n')
              
              if deploy_type == 'dockerfile':
                  runtime = config.get('runtime', {})
                  f.write(f"image_name={runtime.get('image_name', service)}\n")
                  f.write(f"image_tag={runtime.get('image_tag', 'latest')}\n")
                  f.write(f"container_port={runtime.get('container_port', 8080)}\n")
                  f.write(f"host_port={runtime.get('host_port', 8080)}\n")
                  f.write(f"network={runtime.get('network', 'services_network')}\n")
          
          print(f"Service {service} type: {deploy_type}")
          EOF
        env:
          SERVICE: ${{ matrix.service }}

      - name: Set up 1Password CLI
        if: steps.deploy-config.outputs.secrets_required == 'true'
        uses: 1password/install-cli-action@v1

      - name: Load secrets to .env file
        if: steps.deploy-config.outputs.secrets_required == 'true'
        uses: 1password/load-secrets-action@v2
        env:
          OP_SERVICE_ACCOUNT_TOKEN: ${{ secrets.OP_SERVICE_ACCOUNT_TOKEN }}
          DOTENV_FILE: op://Egberinde/${{ matrix.service }}/${{ matrix.environment }}.env
      
      - name: Write .env file
        if: steps.deploy-config.outputs.secrets_required == 'true'
        run: |
          SERVICE="${{ matrix.service }}"
          echo "$DOTENV_FILE" > "services/$SERVICE/.env"
          
          if [ -s "services/$SERVICE/.env" ]; then
            echo "✅ Generated .env with $(wc -l < services/$SERVICE/.env | xargs) variables"
          else
            echo "❌ Failed to generate .env file"
            exit 1
          fi
      
      - name: Skip secrets (not required)
        if: steps.deploy-config.outputs.secrets_required != 'true'
        run: echo "ℹ️  Secrets not required for this service, skipping"

      - name: Deploy with Docker Compose
        if: steps.deploy-config.outputs.type == 'compose'
        run: |
          SERVICE="${{ matrix.service }}"
          TARGET_IP="${{ matrix.ip }}"
          TARGET_USER="${{ matrix.user }}"
          TARGET_ENV="${{ matrix.environment }}"
          SERVER_NAME="${{ matrix.server }}"
          
          echo "Deploying $SERVICE to $SERVER_NAME ($TARGET_IP) in $TARGET_ENV"
          
          # Copy service files to server
          ssh $TARGET_USER@$TARGET_IP "mkdir -p /opt/docker/$SERVICE"
          
          # Copy all files including hidden files like .env
          rsync -avz --include='.*' services/$SERVICE/ $TARGET_USER@$TARGET_IP:/opt/docker/$SERVICE/
          
          # Deploy with Docker Compose and wait for health checks
          # Use --force-recreate to ensure env changes are picked up
          echo "Starting services..."
          if ! ssh $TARGET_USER@$TARGET_IP "set -e; cd /opt/docker/$SERVICE && docker compose pull && docker compose up -d --force-recreate --wait --wait-timeout 15"; then
            echo "❌ Deployment failed - service did not become healthy"
            ssh $TARGET_USER@$TARGET_IP "docker compose -f /opt/docker/$SERVICE/docker-compose.yml logs --tail 50"
            exit 1
          fi
          
          # Initialize SSL if this is nginx
          if [ "$SERVICE" = "nginx" ]; then
            echo "Running SSL initialization for nginx..."
            ssh $TARGET_USER@$TARGET_IP "cd /opt/docker/nginx && bash init-ssl.sh" || echo "SSL initialization will run on first manual setup"
          fi
          
          echo "Service $SERVICE deployed successfully to $SERVER_NAME"

      - name: Deploy with Dockerfile
        if: steps.deploy-config.outputs.type == 'dockerfile'
        run: |
          SERVICE="${{ matrix.service }}"
          TARGET_IP="${{ matrix.ip }}"
          TARGET_USER="${{ matrix.user }}"
          TARGET_ENV="${{ matrix.environment }}"
          SERVER_NAME="${{ matrix.server }}"
          
          IMAGE_NAME="${{ steps.deploy-config.outputs.image_name }}"
          IMAGE_TAG="${{ steps.deploy-config.outputs.image_tag }}"
          CONTAINER_PORT="${{ steps.deploy-config.outputs.container_port }}"
          HOST_PORT="${{ steps.deploy-config.outputs.host_port }}"
          NETWORK="${{ steps.deploy-config.outputs.network }}"
          
          echo "Building and deploying $SERVICE to $SERVER_NAME ($TARGET_IP) in $TARGET_ENV"
          
          # Copy service files to server
          ssh $TARGET_USER@$TARGET_IP "mkdir -p /opt/docker/$SERVICE"
          scp -r services/$SERVICE/* $TARGET_USER@$TARGET_IP:/opt/docker/$SERVICE/
          
          # Build and run container
          ssh $TARGET_USER@$TARGET_IP bash << EOSSH
            set -e  # Exit on any error
            cd /opt/docker/$SERVICE
            
            # Stop and remove old container
            docker stop $SERVICE 2>/dev/null || true
            docker rm $SERVICE 2>/dev/null || true
            
            # Build new image
            docker build -t $IMAGE_NAME:$IMAGE_TAG .
            
            # Run new container
            docker run -d \\
              --name $SERVICE \\
              --network $NETWORK \\
              -p $HOST_PORT:$CONTAINER_PORT \\
              --restart unless-stopped \\
              $IMAGE_NAME:$IMAGE_TAG
            
            echo "Container $SERVICE started successfully"
          EOSSH
          
          echo "Deployment of $SERVICE to $SERVER_NAME completed"

      - name: Health check
        run: |
          SERVICE="${{ matrix.service }}"
          TARGET_IP="${{ matrix.ip }}"
          TARGET_USER="${{ matrix.user }}"
          SERVER_NAME="${{ matrix.server }}"
          
          echo "Verifying deployment of $SERVICE on $SERVER_NAME..."
          
          # Verify container is still running (--wait may have timed out)
          if ssh $TARGET_USER@$TARGET_IP "docker ps --format '{{.Names}}' | grep -q '^${SERVICE}$' || docker compose -f /opt/docker/$SERVICE/docker-compose.yml ps --services --filter 'status=running' | grep -q ."; then
            echo "✅ Service $SERVICE is running and healthy on $SERVER_NAME"
            
            # Show last few log lines for context
            echo "Recent logs:"
            ssh $TARGET_USER@$TARGET_IP "docker logs $SERVICE --tail 10 2>&1 || docker compose -f /opt/docker/$SERVICE/docker-compose.yml logs --tail 10 2>&1"
          else
            echo "❌ Container $SERVICE is not running on $SERVER_NAME"
            echo "Container status:"
            ssh $TARGET_USER@$TARGET_IP "docker ps -a | grep $SERVICE || echo 'No containers found'"
            echo "Container logs (last 50 lines):"
            ssh $TARGET_USER@$TARGET_IP "docker logs $SERVICE --tail 50 2>&1 || docker compose -f /opt/docker/$SERVICE/docker-compose.yml logs --tail 50 2>&1 || echo 'No logs available'"
            exit 1
          fi

  update-nginx:
    needs: [detect-changes, deploy-services]
    if: needs.deploy-services.result == 'success'
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install dependencies
        run: pip install PyYAML

      - name: Generate nginx configuration
        run: python3 scripts/generate-nginx-config.py

      - name: Set up SSH
        run: |
          mkdir -p ~/.ssh
          echo "${{ secrets.DEPLOY_SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

      - name: Deploy nginx configuration to all servers
        run: |
          python3 << 'EOF'
          import yaml
          import subprocess
          import os
          
          # Load servers configuration
          with open('servers.yml') as f:
              servers_config = yaml.safe_load(f)
          
          target_env = os.environ.get('TARGET_ENV', 'production')
          
          # Get all servers in target environment
          env_servers = servers_config.get('environments', {}).get(target_env, [])
          
          for server_name in env_servers:
              server_info = servers_config['servers'][server_name]
              ip = server_info['ip']
              user = server_info['ssh_user']
              
              print(f"Checking for nginx on {server_name} ({ip})...")
              
              # Add to known hosts
              subprocess.run(['ssh-keyscan', '-H', ip], 
                           stdout=open(os.path.expanduser('~/.ssh/known_hosts'), 'a'),
                           stderr=subprocess.DEVNULL)
              
              # Check if nginx exists
              result = subprocess.run(
                  ['ssh', f'{user}@{ip}', 'docker ps -q -f name=nginx-proxy'],
                  capture_output=True, text=True
              )
              
              if result.stdout.strip():
                  print(f"✓ Found nginx on {server_name}, updating configuration...")
                  
                  # Create directory
                  subprocess.run(['ssh', f'{user}@{ip}', 'mkdir -p /opt/docker/nginx'])
                  
                  # Copy nginx config and init script
                  subprocess.run(['scp', 'services/nginx/nginx.conf', 
                                f'{user}@{ip}:/opt/docker/nginx/nginx.conf'])
                  subprocess.run(['scp', 'services/nginx/init-ssl.sh', 
                                f'{user}@{ip}:/opt/docker/nginx/init-ssl.sh'])
                  
                  # Run SSL initialization to get certificates for any new domains
                  print(f"Checking SSL certificates for all domains...")
                  ssl_result = subprocess.run(
                      ['ssh', f'{user}@{ip}', 'cd /opt/docker/nginx && bash init-ssl.sh'],
                      capture_output=True, text=True
                  )
                  print(ssl_result.stdout)
                  
                  if ssl_result.returncode == 0:
                      print(f"✅ Nginx configuration and SSL certificates updated on {server_name}")
                  else:
                      print(f"⚠ SSL initialization had issues, but continuing...")
                      # Try to reload nginx anyway
                      subprocess.run(['ssh', f'{user}@{ip}', 'docker exec nginx-proxy nginx -s reload'],
                                   capture_output=True)
                      print(f"✅ Nginx configuration updated on {server_name}")
              else:
                  print(f"⚠ No nginx found on {server_name}, skipping")
          
          print("\n✅ Nginx configuration update complete")
          EOF
        env:
          TARGET_ENV: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || 'production' }}

  deployment-summary:
    needs: [detect-changes, deploy-services, update-nginx]
    if: always()
    runs-on: ubuntu-latest
    
    steps:
      - name: Deployment summary
        run: |
          echo "## Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Services deployed:** ${{ needs.detect-changes.outputs.services }}" >> $GITHUB_STEP_SUMMARY
          echo "**Deploy status:** ${{ needs.deploy-services.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Nginx update:** ${{ needs.update-nginx.result }}" >> $GITHUB_STEP_SUMMARY
          echo "**Triggered by:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
